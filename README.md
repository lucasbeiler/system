## Details
[Currently](https://github.com/lucasbeiler/system?tab=readme-ov-file#:~:text=and%20then%20actually%20bootstrap%20the%20system%20from%20it), this project builds upon Alpine Linux, a minimal distribution designed with a reduced attack surface and based on the musl libc and BusyBox utils. It serves as a strong foundation for a tightly restricted operating system. The system aims to achieve Full Verified Boot, adoption of modern memory exploit mitigations, and strong isolation and restriction mechanisms to create a cryptographically enforced chain of trust from firmware to userspace.

Full Verified Boot is implemented using UEFI Secure Boot, TPM 2.0, and dm-verity. Kernel and initramfs are combined according to the Unified Kernel Image (UKI) specification. As well as the bootloader, the image combining kernel and initramfs is cryptographically validated by UEFI Secure Boot on every boot, ensuring the integrity and authenticity of the early boot chain. The immutable, read-only root partition is cryptographically validated by dm-verity at each boot, providing integrity and authenticity guarantees for the whole root partition. Any modification to the bootloader, the Unified Kernel Image or the root partition breaks an otherwise successful boot, enforcing a strict chain of trust. TPM 2.0 acts as a hardware root of trust, where user data decryption keys are only accessible if firmware and Secure Boot configurations match a known-good PCR-based measurement. The user data partition (/data) is the only writable and persistent area on disk, and policies strictly prevent execution from there. As a result, the entire executable surface of the system is cryptographically validated.

**Note: Most details are still a work in progress, particularly those described below, many of which have not yet been started at all. These paragraphs are included to illustrate the intended goals.**

**Current status: Boots in QEMU with dm-verity properly validating the root partition; Wayland (sway) and Chromium run fine; OS boots flawlessly even with the read-only filesystems.**

Regarding application security, aside from a Wayland compositor/window manager and some basic utilities, the only primary user-facing application is Chromium, and it has a strong sandboxing architecture by default and advanced, modern exploit mitigations, [see](https://chromium.googlesource.com/chromium/src/+/master/docs/security/rule-of-2.md). For example, Chromium uses [PartitionAlloc](https://chromium.googlesource.com/chromium/src/+/master/base/allocator/partition_allocator/PartitionAlloc.md) as its secure memory allocator and deploys modern exploit mitigations such as Control Flow Integrity, shadow stacks, and memory tagging (on supported hardware). Beyond the browser's own great sandbox, the OS also ensures that Chromium is further restricted and confined under strict Linux Security Module (LSM) policies. Besides Chromium, some system services with higher attack surfaces, such as iwd (the Wi-Fi daemon and DHCP client), are also confined by strict LSM policies. Where applied, LSMs also enforce W^X by preventing memory pages from being both writable and executable at the same time. Chromium will also be further hardened by patches from [Trivalent](https://github.com/secureblue/Trivalent) and [Vanadium](https://github.com/grapheneos/vanadium) (except patches specific to Android/GrapheneOS), and by [running in JITless mode](https://microsoftedge.github.io/edgevr/posts/Super-Duper-Secure-Mode/#:~:text=roughly%2045%25%20of%20CVEs%20issued%20for%20V8%20were%20related%20to%20the%20JIT%20engine). In the future, Chromium's WebAssembly capabilities (even [jitlessly](https://docs.google.com/document/d/1OIJ4Sv2XfTlI5NmTS1QI8v8wPL0LUT5s1W2D9OlJmMc/)) could even make it a secure, sandboxed runtime for C/C++/Rust/Go software compiled to WebAssembly, a growing trend.

In order to provide a flexible yet isolated working environment, a virtual machine runs in the background using [crosvm](https://chromium.googlesource.com/crosvm/crosvm), a Rust-written VMM, on top of the KVM hypervisor. This VM provides local SSH access for development tasks using tools such as tmux, neovim, etc. This way, inside the VM, there's freedom and flexibility.

User data encryption is implemented using the TPM 2.0 hardware chip, which also serves as the root of trust, but without storing the actual LUKS encryption keys in the TPM. Here, as a better approach than what is commonly done, the OS only seals a high entropy value into the TPM, locked behind TPM2 PCR integrity measurements. This value stored in the TPM is used solely as input (along with the user's password) for a Key Derivation Function (argon2id) that produces the final key. This design preserves the integrity and brute-force guarantees provided by the TPM without trusting entirely on the TPM. Furthermore, unsealing requires a rate-limited TPM 2.0 AuthCode/Protector derived from the user's password, so it does not need to be entered separately. Additionally, besides the described LUKS+TPM setup on the /data partition, fscrypt is used to also encrypt each user's home directory (such as /data/home/user/) individually using each user's password, to provide "cryptographic separation" between them and serve as an additional layer.

The kernel is compiled with hardening patches from the [linux-hardened](https://github.com/anthraxx/linux-hardened/commits/6.18) project. Additional hardening is also applied to its build configuration, sysctl flags, and kernel boot parameters. Recommendations from the Kernel Self-Protection Project (KSPP), GrapheneOS, PaX/grsec, and the kernel-hardening-checker are also applied as possible. Over time, all major software components are intended to be compiled with Clang to enable its forward-edge, type-based Control Flow Integrity, including ShadowCallStack on arm64 for backward-edge CFI protections. ARM Memory Tagging Extension (MTE) is also considered as a future enhancement on ARMv9 hardware (but we currently have no ARMv9 laptops out there).

USB and peripheral attack surface is minimized by configuring the kernel's USB subsystem to deny new USB device connections by default (this sysctl toggle is a feature of [linux-hardened](https://github.com/anthraxx/linux-hardened/commit/7a8596bdd792a7f942ab2ee8f332fa80efc2e7dd)), mitigating malicious USB-based exploitation. A system service could be called to toggle this restriction via keyboard shortcuts when the user needs. IOMMU enforcement is also enabled to protect against DMA attacks. Some known "DMA-prone" kernel modules (like thunderbolt) are removed too. In the future, an auto-reboot mechanism will be implemented to reboot the computer when it remains on the lock screen for too long without being unlocked, as a measure to put the user data partition back at rest, encrypted.

A stateful firewall is configured by default using iptables. The firewall permits only outgoing connections and drops incoming packets from connections initiated by remote hosts. This ensures that only locally initiated outbound traffic can establish new network connections, substantially reducing exposure to remote attacks. Unrelated to this, but additionally, the IPv6 implementation is disabled in the kernel to reduce attack surface, since IPv6 does not yet completely replace IPv4; it is better to keep only one implementation enabled, IPv4.

Secure DNS is configured system-wide using [dnscrypt-proxy](https://github.com/DNSCrypt/dnscrypt-proxy). Additionally, Chromium's own secure DNS resolver is configured to use DNS over HTTPS (DoH) using the AdGuardDNS DoH endpoint, which is reasonably privacy-respecting and blocks known ads and malicious domains. ECH/ESNI is also used by Chromium's DNS resolver in order to prevent certain ways of domain name leakage through unencrypted SNI. Finally, for secure network time syncing, the NTP/NTS client is [ntpd-rs](https://github.com/pendulum-project/ntpd-rs), a Rust-written project. Instead of the standard NTP protocol, NTS is used for secure and authenticated time syncing.

Once the robust security model is implemented, instead of simply generating an Alpine rootfs + UKI, the plan is to fork the Alpine aports repository, maintaining only a minimal subset of packages including those necessary for the base operating system, and then actually bootstrap the system from it (and then it wouldn't be Alpine anymore). This would provide greater flexibility to manage package dependencies, custom patches, hardening, using clang to compile certain packages, etc. The overall code quality and the infrastructure to build and test images will also improve substantially compared to its current state (since everything here is currently an experiment around hacky scripts). Reproducible builds and supply chain security are also a goal at last. Another important step in the future will be to replace OpenRC with a different init system, be it s6-init, dinit, runit, or even a custom init implementation to run only the minimum services required by the base OS.